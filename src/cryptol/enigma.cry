alphabet   = [ 'A' .. 'Z' ]
            //ABCDEFGHIJKLMNOPQRSTUVWXYZ
rotorI     = "EKMFLGDQVZNTOWYHXUSPAIBRCJ"
rotorII    = "AJDKSIRUXBLHWTMCQGZNPYFVOE"
rotorIII   = "BDFHJLCPRTXVZNYEIWGAKMUSQO"
notchI     = (1 << asciiToIndex 'Q' ):[26]
notchII    = (1 << asciiToIndex 'E' ):[26]
notchIII   = (1 << asciiToIndex 'V' ):[26]

reflectorB = "YRUHQSLDPXNGOKMIEBFZCWVJAT" // permutation with rotor set to A

// extract offsets from permutation
getReflectorOffsets reflector = [ (26 + r - c) % 26 | c <- alphabet | r <- reflector ]

reflectorBo = getReflectorOffsets reflectorB

doReflector r c = c' where
  ci = asciiToIndex c
  ci' = (ci + r@ci) % 26
  c' = indexToAscii ci'

asciiToIndex c = c - 'A'
indexToAscii i = i + 'A'

doRotorFwd rotor c = rotor @ (asciiToIndex c)
doRotorBwd rotor c = (invertPermutation rotor) @ (asciiToIndex c)

rotateRotor rotor = rotor >>> 1

doOneRotor rotor rOffsets c = doRotorBwd rotor (doReflector rOffsets (doRotorFwd rotor c))

indexOf c shuffle = candidates ! 0 where
    candidates = [ -1 ] # [ if c == s then i else p
                          | s <- shuffle
                          | p <- candidates
                          | i <- [ 0 .. 25 ]
                          ]

invertPermutation shuffle = [ alphabet @ (indexOf c shuffle)
                        | c <- alphabet ]

encryptNoRotate rotor reflector message =
    [ doOneRotor rotor reflectorBo c | c <- message ]

encryptOneRotor rotor reflOf message =
    [ doOneRotor (rotor <<< i) (reflOf >>> i) c
    | c <- message
    | i <- [1 .. 100]
    ]

// encryptAndRotate rotorI reflectorBo "YMXOVPE"
// "GOODJOB"

