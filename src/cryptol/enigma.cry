alphabet   = [ 'A' .. 'Z' ]
            //ABCDEFGHIJKLMNOPQRSTUVWXYZ
rotorI     = "EKMFLGDQVZNTOWYHXUSPAIBRCJ"
rotorII    = "AJDKSIRUXBLHWTMCQGZNPYFVOE"
rotorIII   = "BDFHJLCPRTXVZNYEIWGAKMUSQO"
notchI     = (1 << asciiToIndex 'Q' ):[26]
notchII    = (1 << asciiToIndex 'E' ):[26]
notchIII   = (1 << asciiToIndex 'V' ):[26]

type Char  = [8]
type Rotor = [26](Char,Bit)
type ThreeRotors = [3]Rotor

advanceRotor : Rotor -> Bit -> Rotor
advanceRotor r b = if b then r >>> 1 else r

reflectorB = "YRUHQSLDPXNGOKMIEBFZCWVJAT" // permutation with rotor set to A

// extract offsets from permutation
getReflectorOffsets reflector = [ (26 + r - c) % 26 | c <- alphabet | r <- reflector ]

reflectorBo = getReflectorOffsets reflectorB

doReflector r c = c' where
  ci = asciiToIndex c
  ci' = (ci + r@ci) % 26
  c' = indexToAscii ci'

asciiToIndex c = c - 'A'
indexToAscii i = i + 'A'

doRotorFwd rotor c = rotor @ (asciiToIndex c)
doRotorBwd rotor c = (invertPermutation rotor) @ (asciiToIndex c)

rotateRotor rotor = rotor >>> 1

doOneRotor rotor rOffsets c = doRotorBwd rotor (doReflector rOffsets (doRotorFwd rotor c))

doTwoRotors rotor1 rotor2 rOffsets c =
    doRotorBwd rotor1 (doRotorBwd rotor2 (doReflector rOffsets
        (doRotorFwd rotor1 (doRotorFwd rotor2 c))))

doThreeRotors r1 r2 r3 rOffsets c =
    doRotorBwd r1 (doRotorBwd r2 (doRotorBwd r3 (doReflector rOffsets
        (doRotorFwd r1 (doRotorFwd r2 (doRotorFwd r3 c))))))

indexOf c shuffle = candidates ! 0 where
    candidates = [ -1 ] # [ if c == s then i else p
                          | s <- shuffle
                          | p <- candidates
                          | i <- [ 0 .. 25 ]
                          ]

invertPermutation shuffle = [ alphabet @ (indexOf c shuffle)
                        | c <- alphabet ]

encryptNoRotate rotor reflector message =
    [ doOneRotor rotor reflectorBo c | c <- message ]

encryptOneRotor rotor reflOf message =
    [ doOneRotor (rotor <<< i) (reflOf >>> i) c
    | c <- message
    | i <- [1 .. 100]
    ]

encryptTwoRotors rotor1 rotor2 reflOf message =
    [ doTwoRotors (rotor1 <<< i) (rotor2 <<< i) (reflOf >>> i) c
    | c <- message
    | i <- [1 .. 100]
    ]

encryptThreeRotors r1 r2 r3 reflOf message =
    [ doThreeRotors (r1 <<< i) (r2 <<< i) (r3 <<< i) (reflOf >>> i) c
    | c <- message
    | i <- [1 .. 100]
    ]

// encryptAndRotate rotorI reflectorBo "YMXOVPE"
// "GOODJOB"

getRotations : [3][26] -> ([3][26], [3][2])
getRotations pins = ([lpin', mpin'', rpin'], [lcount', mcount', rcount']) where
    lpin = pins@0
    mpin = pins@1
    rpin = pins@2
    lcount = if mpin!0 then 1 else 0
    mcount = if rpin!0 then 1 else 0
    rcount = 1
    mpin' = mpin <<< 1
    doubleStep = if mpin'!0 then 1 else 0
    lcount' = lcount + doubleStep
    mcount' = mcount + doubleStep
    rcount' = rcount + doubleStep
    mpin'' = mpin <<< doubleStep
    lpin' = lpin <<< lcount'
    rpin' = rpin <<< rcount'


testRotations = [([2,1,1], zero)] # [ getRotations p.0 | p <- testRotations ]
